`BufferedReader`를 사용하는 것이 `Scanner`보다 메모리 사용량이 적고 성능이 더 좋은 이유는 두 클래스의 입력 처리 방식과 설계 차이에서 기인합니다. 두 클래스를 비교해보면 다음과 같은 주요 차이점이 있습니다.

### 1. **버퍼링의 차이**
- `BufferedReader`는 내부적으로 **큰 버퍼**를 사용해 데이터를 한 번에 많이 읽어옵니다. 이 때문에 파일이나 콘솔로부터 데이터를 읽을 때, 여러 번의 입출력을 줄여 효율성을 크게 향상시킵니다.
    - `BufferedReader`는 데이터 스트림에서 한꺼번에 많은 양의 데이터를 읽어 들인 후 필요한 만큼 반환합니다. 이를 통해 **I/O 호출 횟수가 줄어들어** 시간이 절약되고 메모리 사용도 더 효율적입니다.
- 반면 `Scanner`는 주로 입력 스트림에서 **한 번에 한 토큰씩 읽어오는 방식**으로 동작합니다. 즉, 개별적인 데이터 처리에 더 중점을 둡니다. `Scanner`는 토큰화하면서 패턴 매칭까지 처리하는 데 많은 리소스가 필요하게 됩니다.
    - 특히, 입력이 크거나 여러 번 반복되는 경우 `Scanner`는 I/O 호출을 더 많이 하게 되고, 그로 인해 **메모리 사용량과 실행 시간**이 증가합니다.

### 2. **추가적인 기능 제공으로 인한 성능 비용**
- `Scanner`는 입력을 파싱하고 **정규 표현식을 사용하여** 데이터를 토큰 단위로 구분합니다. 숫자, 문자열 등 다양한 형태로 입력을 처리할 수 있기 때문에 더 많은 기능이 제공되는 반면, 그만큼 **오버헤드**가 발생합니다.
    - 예를 들어, `Scanner`는 다음 줄을 읽기 위해 데이터의 형식을 판별하고 구분자로 데이터를 나누기 때문에 메모리 사용량이 늘어나고 더 느리게 작동합니다.
- `BufferedReader`는 단순히 **문자열을 읽는 역할**을 수행합니다. 읽어들인 데이터를 파싱하는 것은 사용자 코드에 맡기므로 더 단순하고 효율적입니다. 파싱이나 토큰화가 필요하다면 `String.split()` 같은 방법을 별도로 사용하여 파싱하면 됩니다. 이 방식은 불필요한 기능을 덜 사용하므로 메모리 효율성이 좋습니다.

### 3. **메모리 및 성능 효율성**
- `BufferedReader`는 단순하게 **문자열 단위로 데이터를 읽어오고** 이를 처리할 수 있게 하기 때문에 상대적으로 메모리 사용량이 적고 빠릅니다. 특히, 큰 입력을 처리할 때 효율적입니다.
- `Scanner`는 여러 가지 입력 형식에 대해 처리할 수 있는 범용적인 기능이 있어, **형식 변환과 정규화** 과정에서 추가적인 비용이 발생하게 됩니다. 이 과정이 반복될 때마다 메모리와 CPU 자원 소비가 증가하게 됩니다.

### 4. **실제 입력 처리 방식의 차이**
- `BufferedReader`는 `readLine()` 메서드를 통해 **한 줄 단위로 문자열을 읽어** 필요한 부분을 직접 나눠서 사용하는 것이 일반적입니다. 이 방식은 최소한의 메모리만 사용하여 데이터를 처리할 수 있습니다.
- 반면 `Scanner`는 내부적으로 입력을 파싱하고, 개별적인 값들을 **정규 표현식으로 구분**하며 데이터를 처리합니다. 이러한 처리 방식은 더 많은 계산과 메모리 할당을 필요로 하며, 입력이 클수록 효율성이 떨어질 수 있습니다.

### 요약
- **BufferedReader**는 데이터를 **버퍼 단위로 한 번에 읽고**, 사용자가 직접 파싱해야 하므로 불필요한 기능이 없고 더 **단순한 작업 흐름**을 갖습니다. 그 결과, 더 적은 메모리를 사용하고 빠르게 동작합니다.
- **Scanner**는 사용 편의성을 위해 **토큰화, 정규식 처리** 등 다양한 기능을 제공하는 대신 메모리 사용량과 성능에서 다소 손해를 봅니다. 특히, **큰 입력 데이터를 처리**할 때 그 차이가 두드러집니다.

따라서, 대규모 데이터를 효율적으로 읽어들이려면 `BufferedReader`를 사용하는 것이 일반적으로 권장되며, 메모리와 성능 면에서 더 유리합니다.